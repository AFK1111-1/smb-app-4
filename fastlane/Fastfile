# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tool

default_platform(:android)

platform :android do
  desc "Build Android debug APK for development"
  lane :dev_build do
    gradle(task: "clean assembleRelease", project_dir: "./android", properties: {
      "android.injected.signing.store.file" => "#{Dir.pwd}/../credentials/android/release.keystore",
      "android.injected.signing.store.password" => ENV['ANDROID_KEYSTORE_PASSWORD'],
      "android.injected.signing.key.alias" => ENV['ANDROID_KEY_ALIAS'],
      "android.injected.signing.key.password" => ENV['ANDROID_KEY_PASSWORD']
    })
  end

  desc "Submit a new internal test build to play store"
  lane :qa_release do
    previous_build_number = google_play_track_version_codes(
      track: "internal",
      json_key: "credentials/android/google-play-service-key.json"
    )[0]

    increment_version_name(
      gradle_file_path: "android/app/build.gradle"
    )
    increment_version_code(
      gradle_file_path: "android/app/build.gradle",
      version_code: previous_build_number + 1
    )

    gradle(task: "clean bundleRelease", project_dir: "./android", properties: {
      "android.injected.signing.store.file" => "#{Dir.pwd}/../credentials/android/release.keystore",
      "android.injected.signing.store.password" => ENV['ANDROID_KEYSTORE_PASSWORD'],
      "android.injected.signing.key.alias" => ENV['ANDROID_KEY_ALIAS'],
      "android.injected.signing.key.password" => ENV['ANDROID_KEY_PASSWORD']
    })

    upload_to_play_store(
      track: 'internal',
      json_key: "credentials/android/google-play-service-key.json",
      aab: "android/app/build/outputs/bundle/release/app-release.aab"
    )

    changelog_from_git_commits
  end

  desc "Submit a new production build to play store"
  lane :production_release do
    increment_version_name(
      gradle_file_path: "android/app/build.gradle"
    )
    increment_version_code(
      gradle_file_path: "android/app/build.gradle"
    )

    gradle(task: "clean bundleRelease", project_dir: "./android", properties: {
      "android.injected.signing.store.file" => "#{Dir.pwd}/../credentials/android/release.keystore",
      "android.injected.signing.store.password" => ENV['ANDROID_KEYSTORE_PASSWORD'],
      "android.injected.signing.key.alias" => ENV['ANDROID_KEY_ALIAS'],
      "android.injected.signing.key.password" => ENV['ANDROID_KEY_PASSWORD']
    })

    upload_to_play_store(
      track: 'production',
      release_status: "draft",
      json_key: "credentials/android/google-play-service-key.json",
      aab: "android/app/build/outputs/bundle/release/app-release.aab"
    )
  end
end

platform :ios do

  desc "Build iOS simulator app for development"
  lane :dev_build do
    build_ios_app(
      workspace: "ios/smbmobile.xcworkspace",
      scheme: "smbmobile",
      sdk: "iphonesimulator",
      configuration: "Debug",
      derived_data_path: "ios/build",
      output_directory: "ios/build",
      output_name: "smbmobile.app"
    )
  end

  desc "Submit a new QA build to TestFlight"
 
  lane :qa_release do
    # Debug: Log environment variables and file
    UI.important "=== Fastlane Environment Debug ==="
    UI.message "APP_STORE_CONNECT_API_KEY_ID: #{ENV['APP_STORE_CONNECT_API_KEY_ID'] ? '‚úÖ SET' : '‚ùå NOT SET'}"
    UI.message "APP_STORE_CONNECT_ISSUER_ID: #{ENV['APP_STORE_CONNECT_ISSUER_ID'] ? '‚úÖ SET' : '‚ùå NOT SET'}"
    UI.message "MATCH_PASSWORD: #{ENV['MATCH_PASSWORD'] ? '‚úÖ SET' : '‚ùå NOT SET'}"
    if ENV['MATCH_PASSWORD']
      UI.message "MATCH_PASSWORD length: #{ENV['MATCH_PASSWORD'].length} characters"
      UI.message "MATCH_PASSWORD value: '#{ENV['MATCH_PASSWORD']}'"
    end
    
    key_path = "credentials/ios/AuthKey.p8"
    UI.message "Key file path: #{key_path}"
    
    if File.exist?(key_path)
      file_size = File.size(key_path)
      UI.message "Key file exists: ‚úÖ YES (#{file_size} bytes)"
      
      # Check for null bytes
      content = File.read(key_path)
      if content.include?("\x00")
        UI.error "‚ùå ERROR: File contains null bytes!"
        UI.error "First 100 chars: #{content[0..100].inspect}"
      else
        UI.success "‚úÖ No null bytes detected"
        UI.message "File starts with: #{content[0..50]}"
      end
    else
      UI.error "Key file exists: ‚ùå NO"
    end
    UI.important "==================================="

    api_key = app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_ISSUER_ID'],
      key_filepath: "#{Dir.pwd}/../credentials/ios/AuthKey.p8"
    )

    match(
      type: "appstore",
      readonly: false,
      app_identifier: "com.insighture.smbmobile",
      git_url: "git@github.com:insighture/smb-mobile-fastlane.git",
      api_key: api_key,
      force_for_new_devices: true,
      keychain_password: ENV['KEYCHAIN_PASSWORD'],
      keychain_name: ENV['KEYCHAIN_NAME']
    )
    
    # Update Xcode project with team ID and provisioning profile
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "ios/smbmobile.xcodeproj",
      team_id: "96W7U4JYV4",
      profile_name: "match AppStore com.insighture.smbmobile",
      code_sign_identity: "iPhone Distribution",
      targets: ["smbmobile"]
    )

    # ‚úÖ Fix for versioning
    increment_version_number(
      xcodeproj: "ios/smbmobile.xcodeproj",
      bump_type: "patch"
    )
    
    # Get the latest build number from TestFlight and increment from there
    begin
      latest_build = latest_testflight_build_number(
        app_identifier: "com.insighture.smbmobile",
        api_key: api_key
      )
      UI.message "üìä Latest TestFlight build number: #{latest_build}"
      
      # Set build number to latest + 1 (proper sequential numbering)
      # The retry logic below will handle any duplicate conflicts automatically
      new_build_number = latest_build + 1
      increment_build_number(
        xcodeproj: "ios/smbmobile.xcodeproj",
        build_number: new_build_number
      )
      UI.success "‚úÖ Build number set to: #{new_build_number}"
    rescue => ex
      UI.important "‚ö†Ô∏è  Could not fetch latest TestFlight build number: #{ex.message}"
      UI.message "Using increment from Xcode project instead"
      increment_build_number(
        xcodeproj: "ios/smbmobile.xcodeproj"
      )
    end

    UI.message "üî® Building and archiving iOS app..."
    UI.message "Using Xcode 16.1 - letting gym auto-detect best build strategy"
    UI.message ""
   
    # Let gym handle both archiving AND exporting in one step
    # This avoids manual destination issues
    build_ios_app(
      workspace: "ios/smbmobile.xcworkspace",
      scheme: "smbmobile",
      configuration: "Release",
      export_method: "app-store",
      output_directory: "./ios/build",
      output_name: "smbmobile.ipa",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "com.insighture.smbmobile" => "match AppStore com.insighture.smbmobile"
        },
        teamID: "96W7U4JYV4"
      },
      xcargs: "ONLY_ACTIVE_ARCH=NO ENABLE_BITCODE=NO COMPILER_INDEX_STORE_ENABLE=NO",
      skip_profile_detection: true
    )
   
    UI.success "‚úÖ iOS app built and exported successfully!"

    # Upload to TestFlight with retry logic for duplicate build numbers
    max_retries = 3
    retry_count = 0
    upload_success = false
    
    while retry_count < max_retries && !upload_success
      begin
        upload_to_testflight(
          skip_waiting_for_build_processing: true,
          api_key: api_key
        )
        upload_success = true
        UI.success "‚úÖ Successfully uploaded to TestFlight!"
      rescue => ex
        if ex.message.include?("bundle version must be higher") || ex.message.include?("DUPLICATE")
          retry_count += 1
          UI.important "‚ö†Ô∏è  Build number conflict detected (attempt #{retry_count}/#{max_retries})"
          
          if retry_count < max_retries
            # Get current build number and increment
            current_build = get_build_number(xcodeproj: "ios/smbmobile.xcodeproj")
            new_build = current_build.to_i + 1
            
            UI.message "üîÑ Incrementing build number from #{current_build} to #{new_build} and rebuilding..."
            
            # Increment build number
            increment_build_number(
              xcodeproj: "ios/smbmobile.xcodeproj",
              build_number: new_build
            )
            
            # Rebuild the app with new build number
            build_ios_app(
              workspace: "ios/smbmobile.xcworkspace",
              scheme: "smbmobile",
              configuration: "Release",
              export_method: "app-store",
              output_directory: "./ios/build",
              output_name: "smbmobile.ipa",
              export_options: {
                method: "app-store",
                provisioningProfiles: {
                  "com.insighture.smbmobile" => "match AppStore com.insighture.smbmobile"
                },
                teamID: "96W7U4JYV4"
              },
              xcargs: "ONLY_ACTIVE_ARCH=NO ENABLE_BITCODE=NO COMPILER_INDEX_STORE_ENABLE=NO",
              skip_profile_detection: true
            )
            
            UI.success "‚úÖ Rebuilt with build number #{new_build}"
          else
            UI.error "‚ùå Failed after #{max_retries} attempts"
            raise ex
          end
        else
          # Different error, don't retry
          raise ex
        end
      end
    end

    changelog_from_git_commits
  end

  desc "Submit a new staging build to TestFlight"
  lane :stg_release do
    increment_version_number(
      xcodeproj: "ios/smbmobile.xcodeproj",
      bump_type: "patch"
    )
    increment_build_number(
      xcodeproj: "ios/smbmobile.xcodeproj"
    )

    build_ios_app(
      workspace: "ios/smbmobile.xcworkspace",
      scheme: "smbmobile",
      export_method: "app-store",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "com.insighture.smbmobile" => "match AppStore com.insighture.smbmobile"
        }
      },
      output_directory: "ios/build",
      output_name: "smbmobile.ipa",
      team_id: ENV['APPLE_TEAM_ID'] || "96W7U4JYV4"
    )

    upload_to_testflight(
      skip_waiting_for_build_processing: true
    )

    changelog_from_git_commits
  end

  desc "Submit a new production build to App Store"
  lane :production_release do
    increment_version_number(
      xcodeproj: "ios/smbmobile.xcodeproj",
      bump_type: "patch"
    )
    increment_build_number(
      xcodeproj: "ios/smbmobile.xcodeproj"
    )

    build_ios_app(
      workspace: "ios/smbmobile.xcworkspace",
      scheme: "smbmobile",
      export_method: "app-store",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "com.insighture.smbmobile" => "match AppStore com.insighture.smbmobile"
        }
      },
      output_directory: "ios/build",
      output_name: "smbmobile.ipa",
      team_id: ENV['APPLE_TEAM_ID'] || "96W7U4JYV4"
    )

    upload_to_app_store(
      skip_metadata: true,
      skip_screenshots: true,
      precheck_include_in_app_purchases: false
    )

    changelog_from_git_commits
  end

  desc "Submit a new production build to App Store (legacy)"
  lane :release do
    increment_version_number(
      xcodeproj: "ios/smbmobile.xcodeproj",
      bump_type: "patch"
    )
    increment_build_number(
      xcodeproj: "ios/smbmobile.xcodeproj"
    )

    build_ios_app(
      workspace: "ios/smbmobile.xcworkspace",
      scheme: "smbmobile",
      export_method: "app-store",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "com.insighture.smbmobile" => "match AppStore com.insighture.smbmobile"
        }
      },
      output_directory: "ios/build",
      output_name: "smbmobile.ipa",
      team_id: ENV['APPLE_TEAM_ID'] || "96W7U4JYV4"
    )

    upload_to_app_store(
      skip_metadata: true,
      skip_screenshots: true,
      precheck_include_in_app_purchases: false
    )

    changelog_from_git_commits
  end
end
